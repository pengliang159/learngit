1.应用程序使用Log4j2 API从LogManager根据指定名字获取Logger请求，LogManager将会寻找合适的LoggerContext并且获得Logger对象。
如果Logger被创建，它将与以下关联：
a 与Logger同名的LoggerConfig, b. 父包的名字
或者
c.根 LoggerConfig， LoggerConfig对象是从在configuration中声明的Logger中获取的。
LoggerConfig与传送LogEvents的Appender关联。

LoggerContext
LoggerContext 是日志系统的锚点，取决于不同的环境，LoggerContext可以在一个应用里存在多个。

Configuration
每个LoggerContext都有一个Configuration.Configuration包含所有的Appenders,context-wide Filter,LoggerConfigs 和包含引用的StrSubsitutor. 在重新配置期间会有两个Configuration 对象，一旦所有的Loggers完成了指向了新的Configuration,旧的Configuration将会停止并且废弃。

Logger
Logger 是调用 LogManager.getLogger创建的.Logger本身没有直接的执行动作。它只有简单的名字并且和LoggerConfig关联。它继承自AbstractLogger并且实现了必须的方法。当配置被修改后，Logger可能与新的LoggerConfig相关联

用相同的名字调用LogManager.getLogger方法将返回完全相同的Logger对象
Logger x = LogManager.getLogger("wombat"); Logger y = LogManager.getLogger("wombat"); x和y是完全相同的Logger对象

log4j 的环境配置通常在应用初始化时完成。在class后声明loggers目前看来是最好的方式。
LogManager.getLogger()会自动使用全类名作为Logger的名称

LoggerConfig 
LoggerConfig是Loggers在logging configuration声明时创建的。LoggerConfig包含的Filter会在LogEvent到达Appenders前校验。它包含一系列的Appenders将会处理这些事件。
LoggerConfig将会分配一下日志等级。内置的日志等级有 TRACE,DEBUG,INFO,WARN,ERROR,FATAL。等级由低到高。log4j2也支持自定义日志等级。另外的机制是使用Markers 获取更多的粒度。
不同于 Log4j和Logback的相同等级继承 理念。Log4j2的  Logger和LoggerConfig是实现方式不同的两个不同对象，每个Logger和合适的能依次引用父级的LoggerConfig关联，来完成相同的效果。

Filter
过滤器可以应用在control传递给LoggerConfig之前，control传递给LoggerConfig之后但是调用任何Appenders之前，control传递给LoggerConfig之后但是调用指定的Appender之前，并且在每个Appender之上。与防火墙过滤的方式相同，每个Filter从Accept、Deny、Neutral三个结果中返回一个。Accept表示不会在调用其他Filter并且通过。Deny表示立即拒绝并且返回给请求者。Neutral表示传递给其他过滤器，如果没有其他过滤器将会通过。
即使一个事件可能会被Filter通过但依然不会logged.这种可能是发生在事件被pre-LoggerConfig 过滤器通过但是被LoggerConfig或者Appenders拒绝。

Appender
基于他们的logger有选择的启用或禁用日志请求只是一部分。Log4j允许日志请求打印到多个终端。在log4j中，一个输出终端就叫做一个Appender.现在，Appender存在于 console,文件、remote socket server, Apache Flume, JMS, remote UNIX Syslog daemons 和各种数据库接口。
可以在当前的Configuration中调用addLoggerAppender方法去添加一个Appender，如果LoggerConfig按名称匹配的Logger不存在，将会创建一个，Appender将会附属于它并且会通知所有的Loggers去更新他们引用的LoggerConfig.
每个启用记录请求的logger将会转发给所有的Logger的LoggerConfig中的所有的Appenders包括Appender的LoggerConfig的父类。也就是说，Appenders会从父级中的LoggerConfig继承。比如，如果一个root logger上有一个console appender，那么所有启用日志请求将至少会打印在console上。
在配置文件中的Logger声明上加上  additivity="false" 可以不让Appender上继承父类的默认行为
appender可加性规则总结：
一个输出日志语句将会打印在与Logger的LoggerConfig和他的父级们相关的所有Appender上。但是一个有了  additivity="false" 属性的Logger将不会附加上父类中的appenders。Logger的 additivity属性默认值是true

Layout
自定义输出格式。Layout负责格式化输出的内容，appendder负责发送格式化后的内容到终端。
PatternLayout,标准log4j的一部分， 和C语言的printf方法相似，让用户根据指定的转换模式输出。


占位参数：
Logger.debug("Logging in user {} with birthday {}", user.getName(), user.getBirthdayCalendar());
同样可以使用java的格式化，如，注意这个需要使用LogManager.getFormatterLogger才行。
Logger.debug("Logging in user %s with birthday %s", user.getName(), user.getBirthdayCalendar());

当然两者也可以混用。不需要使用LogManager.getFormatterLogger。使用
logger.printf(level.INFO, "Logging %s...")，但是有个缺点是必须使用与之对应的类型，否则会抛异常。

日志名称
大多数时候都是使用当前类的路径，所以 LogManager.getLogger() 就可以获取到当前类的路径。

流跟踪
Logger类提供了跟踪程序执行路径的非常有用的方法。这些方法生成日志事件，可以分开过滤其他调试日志记录。
鼓励不拘束的使用这些方法可以
1.不需要调试会话来诊断问题。
2.使不用调试来诊断问题成为可能。
3.帮助新开发者学习程序

最常用的两个方法是 entry() 和 exit()
entry()是放在方法最前面的，除了那些简单的方法如getter或者setter。
exit()是放在方法最后面的或者有return的之前。void方法一般使用exit(),返回一个对象的时候一般使用 exit(Object obj).
throwing方法被用于程序抛一个不太可能被处理的异常，比如说RuntimeException.
catching用于程序捕获一个方法

Markers
日志框架的一个主要目的是为了生成的日志和诊断信息只是他需要的，并且允许过滤那些信息以至于不会让有用的信息被系统淹没或者个人需要它。

Event Logging
EventLogger类提供了一个发生在程序中的记录事件的简单机制。
推荐在一个普通的web应用中使用EventLogger的方法是用ThreadContext Map填充关联到请求的整个生命周期数据，比如 user's id, user's ip addres, the product name 等等。这能很轻松的在一个servlet filter中完成，ThreadContext map也能在请求结束后在servlet filter中被清除。

Messages
虽然Log4j 提供了接收Strings和Objects的方法，所有这些最终还是被Message Objects所捕获然后和log event相关联.应用自由的构建他们自己的消息并且传送给Logger.
虽然它看起来更加昂贵比直接传送message format和参数到event，测试表明和现代JVM创建和销毁事件的花费相比，它微不足道，尤其是在Message中封装的复杂的任务而不是程序中。此外，当使用接收Strings和参数的方法，底层的Message Object将仅仅被会创建如果配置了任何全局filter或者允许Logger's log event去处理
应用有一个Map对象包含 {"Name" = "John Doe", "Address" = "123 Main St.", "Phone" = "(999) 555-1212"}和一个用户对象有一个getId方法返回"jdoe".开发者想增加一条信息returns""User John Doe has logged in using id jdoe"，可能这样去实现：
logger.info("User {} has logged in using id {}", map.get("Name"), user.getId());
虽然这本身没什么错，但是作为一个复杂的对象并且期望输出更多这个方式可能变的很难去使用。一种替代方式，Message可以这样：logger.info(new LoggedInMessage(map, user));
public class LoggedInMessage implements Message 去实现 getFormattedMessage 方法。

FormattedMessage
消息模式传送给FormattedMessage，首先会检查是否存在一个合法的java.text.MessageFormat模式，如果有，将会使用MessageFormatMessage去格式化它，没有将检查是否包含任何可以用String.format()的合法格式符，有的话，将会使用StringFormattedMessage，否则会使用PrameterizedMessage去格式化。

LocalizedMessage
LocalizedMessage首先提供兼容Log4j1.x。一般的，最好的本地化的方法是让客户端UI在客户端本地呈现事件，
LocalizedMessage结合了ResourceBundle并且允许消息模式参数成为消息模式包的关键。如果没有bundle被指定，LocalizedMessage将会试图通过Logger的名称加载bundle去记录事件。使用FormattedMessage格式化从bundle中找到的message

LoggerNameAwareMessage
LoggerNameAwareMessage是一个有setLoggerName方法的接口，这个方法会在事件构建的时候被调用，所以the Message有Logger的名称去记录事件当消息正在被格式化。

MapMessage
一个MapMessage包含map的String key和values。MapMessage实现了FormattedMessage并且接收XML的格式说明符，这种情况下Map将被格式为XML，另外，Map将会被格式化成 "key1=value1 key2=value2...".

MessageFormatMessage
使用conversion format(http://docs.oracle.com/javase/6/docs/api/java/text/MessageFormat.html)处理消息。虽然它比ParameterizedMessage更加灵活，但是也差不多慢两倍。

MultiformatMessage
将有一个getFormats方法和一个接收格式化的String类型的数组的getFormattedMessage方法。getFormats()方法也许被Layout调用去提供Message支持的格式化参数。Layout也许接着调用getFormattedMessage方法带着一个或多个formats。如果Message不识别format name,它将会使用默认的格式简单的格式数据。

ObjectMessage 调用它的toString方法去格式化一个对象

ParameterizedMessage 处理在格式化中包含{}的可替换符和可替换参数

SimpleMessage 包含一个不需要格式化的String

StringFormattedMessage 使用符合java.lang.String.format()的 conversion format去处理消息，虽然比ParamterizedMessage更加灵活，但同时比ParameterizedMessage慢5到10倍。

StructuredDataMessage 作为一个符合RFC 5424有结构的数据元素允许应用添加项到Map和设置id到message去格式化。

ThreadDumpMessage 一个ThreadDumpMessage，如果记录，将会为所有的线程生成stack traces.在java6以上stack traces将包含他们held的任何锁

TimestampMessage 在事件构建时将提供一个getTimestamp方法去调用，将使用当前时间作为消息的时间戳

配置loggers
每一个配置都必须有一个root logger，如果没有配置，就会有一个等级为Error，输出到Console的logger被使用。
root logger 和其他的logger的主要区别是：
1.root logger 没有名称属性
2.root logger因为没有父级所以不支持additivity属性

配置Appenders
一个Appender要么使用指定的appender插件名称，要么是一个appender节点并且属性里包含appender插件的名称。在appenders中每个appender必须包含一个有值的名称属性并且是唯一的。这个名字将会被logger引用。

配置Filters
filter节点可以出现在4个地方
1.与properties、loggers、appenders同级的节点.这些filter能在事件传送给LoggerConfig接收或者拒绝事件。
2.在logger节点里，用于给指定的logger过滤
3.在appender节点里，能阻止事件被appender处理
4.在一个appender引用节点里，用于决定使用哪一个appender

XInclude
XML配置文件可以使用XInclude引入其他的配置文件。
<configuration xmlns:xi="http:www.x3.org/2001/XInclude">
<xi:include href="log4j2-appenders.xml"/>
</configuration>

Status Message
Troubleshooting tip for the impatient:
在配置被发现之前，状态日志等级可以通过系统属性org.apache.logging.log4j.simplelog.StatusLogger.level进行控制
在配置被发现后，状态日志等级可以通过配置文件的status进行控制。如:<Configuration status="trace">

在应用中它是能够诊断问题，它是频繁的需要能够在日志配置或者配置组件中诊断问题的。日志还没有配置的时候，在初始化期间"normal"日志将不能被使用.另外，appenders中的normal logging能创建无限循环的log4j检测到的并且会导致循环事件被忽略。为了满足这种需求，Log4j API包含了一个StatusLogger.组件声明StatusLogger的示例：protected final static Logger logger = StatusLogger.getLogger();
自从StatusLogger实现了Log4j2 API的Logger接口，所有normal Logger方法都可能被使用。

当配置Log4j的时候它可能需要去查看生成的状态事件.这个可以通过添加状态属性或者通过设置"Log4jDefultStatusLevel"系统属性提供的默认值来完成.status属性合法的值是"trace"，"debug","info","warn","error"和"fatal"。

如果状态属性设置为error，将仅仅只会有error消息写到console。

在Web应用中使用Log4j
配置：可以在web.xml中通过log4jConfiguration context parameter指定配置文件。
1.如果指定了位置将会作为一个servlet context资源查找。比如log4jConfiguration包含了logging.xml将会在web应用的根目录里查找有这个名字的文件。
2.如果没有指定位置，将会在web-inf目录中查找以log4j2开始的文件名，如果发现了多个文件，如果发现了log4j-[name]的文件[name]是web应用的名字，将会使用这个文件，否则会使用第一个发现的文件。
3.正常的查找顺序是使用类路径并且使用文件URLs去查找配置文件

简单地说，Log4j2 能在Servlet3.0中自动的在应用部署时启动和在关闭部署时关闭。因为Servlet3.0中的ServeltContainerInitializer API能使相关的Filter和ServletContextListener类能动态的在web应用在启动时注册。
重要提示：因为性能的原因，容器通常忽略某些jar不包含TLDs或ServletContainerInitializers和不扫描他们web-fragments和初始化。小于7.0.43的tomcat7忽略所有叫log4j*.jar。但是已经在7.0.43、tomcat8 和更高的版本中修复。

The Long Story
在程序中，Log4j2 WEB JAR文件是一个web-fragment应该配置在其他web fragments的前面。它包含了一个能自动并且初始化的ServletContainerInitializer容器。它把Log4jServletContextListener和Log4jServletFilter加到ServletContext中。那些类正确的初始化和取消初始化Log4j的配置
如果不想自动的配置Log4j，可以在web.xml配置 <context-param><param-name>isLog4jAutoInitializationDisabled</param-name><param-value>true</param-value></context-param>禁止自动配置。

Context Parameters
默认的，Log4j2 使用ServletContext的context name作为LoggerContext名字并且使用标准模式查找Log4j的配置文件。可以使有三个context parameters来控制这个行为。第一，isLog4jContextSelectorNamed,指定是否使用JndiContextSelector。如果isLog4jContextSelectorNamed没被指定或者值不是true，则将会取false.
如果isLog4jContextSelectorNamed不是true，log4jConfiguration可以自定义的设置并且必须是一个合法的URI或者是配置文件的路径或者使用classpath:去类路径下寻找配置文件。没有这个参数，Log4j将会使用标准的机制去加载配置文件。
当指定这些context parameters，即使在servlet3.0以上，你也必须在web.xml中指定他们的值，如果你在Listener中把他们加到ServletContext中，Log4j将在context paramaters可用前初始化，并且他们没有影响。

在配置期间使用Web应用信息
在可以在Rolling File Appender中嵌入web application的context路径。

JavaServer Pages Logging
你可能在jsp中使用Log4j2就像你在jsp中使用java代码一样。很容易获取一个Logger并且对日志事件调用它的方法。但是这需要你在jsp中使用java代码，有些开发团队对这个感觉不太舒服。所以Log4j提供了一个JSP Tag Library可以使你不使用java代码去记录日志。

异步请求和线程
处理异步请求是困难的，并且Servlet container version无视的。或者配置Log4j不能自动的处理一切。当标准request，forwards，includes和error resources 被处理，Log4jServletFilter给线程绑定LoggerContext去处理请求。当请求处理完成，filter会给线程取消绑定LoggerContext.
相似的，当使用一个javax.servletAsyncContext发送一个内部请求，Log4jServletFilter同样会给线程绑定LoggerContext去处理请求和请求处理完成时取消绑定。然而，这个仅仅会通过AsyncContext发送请求时发生。有其他的异步活动能替代内部的转发。
比如，在启动一个AsyncContext之后你能在后台启动一个分离的线程去处理请求。可能通过SerlvetOutputStream返回.Filters不能拦截这个线程的执行。Filters也不能拦截你在后台开始的非异步请求。这是真的当你使用一个新线程或者从线程池中取线程。所以你能为这些特别的线程做些什么？
你也许不用做任何事。如果你不使用isLog4jContextSelectorNamed context parameter,这就不需要给线程绑定LoggerContext.Log4j能安全的定位它自己的LoggerContext.这些案例中，filter仅当创建新的Logger的时候提供适度的性能增益。如果你将isLog4jContextSelectorNamed context param的值设置为true，你将需要手工绑定LoggerContext到异步的线程。否则，Log4j将不能找到它。
幸亏，Log4j提供了一个简单的机制去绑定LoggerContext到异步的线程在那些特殊的状况。最简单的方式是在传递给AsyncContext.start中的Runnable中绑定。
另一种选择，你可以从ServletContext属性中获取Log4jWebLifeCycle实例。调用它的setLoggerContext方法作为异步线程中的第一行代码，然后在最后一行调用它的clearLoggerContext方法。记住一定要在线程完成处理后调用clearLoggerContext，否则将会导致内存泄露。如果使用一个线程池，它甚至能打断容器中其他的web程序的日志。所以应该把clearLoggerContext放在finally里。

插件
在Log4j2是在类声明上使用@Plugin注解去定义一个插件。在初始化配置的时候将会调用PluginManager去加载Log4j的插件和自定义插件。PluginManager将会在4个地方查找插件：
1.在类路径中序列化的插件清单文件。这些文件在构建期间自动生成。
2.在每一个OSGI中的序列化插件清单文件。BundleListener在log4j-core启动后被加入去继续检查新的bundles
3.一个逗号分隔的通过log4j.plugin.packages系统属性指定的包名。
4.在Log4j配置启动前，使用PluginManager.addPackages添加的包
5.在log4j2配置文件中声明的包
如果多个插件指定了相同的名字(区分大小写)，将会根据加载靠前的顺序决定使用哪一个。例如，在FileAppender中去重写一个File插件，你需要在类路径中将你的jar文件放在log4j-core.jar前面，这是不推荐的。插件名称冲突将会导致一个警告。记住在一个OSGI环境中，为插件按顺序扫描到的bundles生成顺序和安装到框架中的bundles顺序是一致的。长话短说，命名冲突会导致更多不可预测在OSGI环境中。
序列化插件清单文件被注解处理器生成包含在log4j-core artifact中能自动为log4j插件扫面你的代码并且输出一个metadata文件在你的处理类中。没有什么额外的操作去完成来使它可用。java编译会自动的pick up注解在类路径上除非你明确地禁用它。在这些案例中，它将会是重要的去添加另一个编译通过仅仅处理使用log4j 2的注解处理类来通过你的构造处理程序。
暂时不写插件文档了，大概不会用到。

Lookups
Lookups提供一种方式在任意地方去添加值到Log4j配置。他是一个实现了StrLookup接口的特定类型的插件

Context Map Lookup
ContextMapLookup允许程序在Log4j ThreadContext Map中存储数据并且在Log4j配置里取出数据。

Date Lookup
DateLookup是有点不寻常的因为它不使用key去定位一个item。而是，这个key可以被使用去指定一个合法的SimpleDateFormat日期格式字符串。
f
EnvironmentLookup
EnvironmentLookup允许系统配置环境变量，可以是想 /etc/profile的全局文件或者是在程序的启动脚本中。并且取回在logging configuration中取回那些值。

Java Lookup
JavaLookup能很方便的使用java:前缀取回java环境信息
verision 取回java的版本信息,比如：Java version 1.7.0_67
runtime 运行时环境  vm java虚拟机版本  os系统版本  
locale locale information 比如：default locale:en_US, platform encoding:Cp1252
hw 硬件信息，比如：processors:4, architecture:amd64-64,instruction sets: amd64

Jndi Lookup
JndiLookup 能通过JNDI取到数据，


Appenders
Appenders负责运输LogEvents到目的地。每一个Appender必须实现Appender接口。大多数Appenders将继承添加了Lifecycle和支持Filterable的AbstractAppender。Lifecycle允许组件在配置完成后初始化和做清理在关闭期间。Filterable允许组件在事件处理期间过滤。

Appenders经常仅仅负责写event data到目标地方。在大多数案例他们格式化event到layout。一些Appenders 被其他Appender包裹，所以他们能修改LogEvent,处理一个失败的在一个Appender，....

AsyncAppender
AsyncAppender允许关联到其他的Appender并且能在一个分离的线程中写LogEvents.记住当写这些异常到那些Appenders将会从应用中隐藏。The AsyncAppender应该被配置在他引用的appenders之后允许它能正确的关闭。

