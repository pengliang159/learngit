java并发编程实践
FIFO：first in first out 先进先出
LIFO：last in first out 后进先出
原子性：同一个时刻只有一个线程对它操作。
1.无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对变量的访问。java中首要的同步机制是synchronized关键字，它提供了独占锁。除此之外，术语“同步”还包括volatile变量，显示锁和原子	变量的使用
	在没有正确同步的情况下，如果多个线程访问了同一个变量，你的程序就存在隐患。有3种方法修复它：
		a).不要跨线程共享变量
		b).使状态变量为不可变的；
		c).在任何访问状态变量的时候使用同步
2.竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。
竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。
3.线程安全型：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。要求无论是多线程中的时序或交替操作，都要保证不破坏那些不变约束。
4.java.util.concurrent.atomic 包中包括了原子变量类，这些类用来实现数字和对象引用的原子状态转换。
5.每个java对象都可以隐式地扮演一个用于同步的锁的角色：这些内置的锁被称作内部锁或监视器锁。执行线程进入synchronized块之前会自动获得锁；而无论通过正常控制路径退出，还是从块中抛出异常，线	程都在放弃对synchronized块的控制时自动释放锁。获得内部锁的唯一途径事：进入这个内部锁保护的同步块或方法。
6.互斥锁：内部锁在Java中扮演了互斥所的角色。意味着至多只有一个线程可以拥有锁，当线程A尝试请求一个被线程B占有的锁时，线程A必须等待或者阻塞，直到B释放它。如果B永远不释放锁，A将永远等下去
7.对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的。
8.即使获得了与对象关联的锁也不能阻止其他线程访问这个对象，获得对象的锁后，唯一可以做的事情是阻止其他线程再获得相同的锁。
9.一种常见的锁规则是在对象内部封装所有的可变状态，通过对象的内部锁来同步任何访问可变状态的代码路径，保护他在并发访问中的安全。
10.对于每一个涉及多个变量的不变约束，需要同一个锁保护其所有的变量。
11.使用两种不同的同步机制会引起混淆，而且性能与安全也不能从中得到额外的好处。
12.通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地为了性能而牺牲简单性。
13.同步数据，避免访问过期值，使用  get/set 封装 。并在方法上加上 synchronized 关键字或者使用锁
14.锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步。
15.volatile：它确保对一个变量的更新以可预见的方式告知其他的线程。
16.正确使用volatile变量的方式：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件(比如初始化或关闭)的发生。他们通常当做标识完成、中断、状态的标记使用。volatile不足以使自增操作原子化。  当验证正确性必须推断可见性问题时，应该避免使用volatile变量。加锁可以保证可见性和原子性；volatile只能保证可见性。
只有满足以下所有标准，才能使用volatile变量
	a).写入变量时并不依赖变量的当前值；或者能够确保只有单一的线程修改变量的值。  所以i++ 不适合。
	b).变量不需要与其他的状态变量共同参与不变约束，而且访问变量时，没有其他的原因需要加锁。
	
17.发布：发布一个对象的意思是使它能够被当前范围之外的代码所使用。比如将一个引用存储到其他代码可以访问的地方，在一个非私有的方法中返回这个引用，也可以把它传递到其他类的方法中。
18.逸出：一个对象在尚未准备好时就将它发布，称为逸出
19.为了安全的发布对象，对象的引用以及对象的状态必须同时对其他线程可见。
	可通过下列条件安全的发布一个正确创建的对象：
		a).通过静态初始化器初始化对象的引用
		b).将它的引用存储到volatile域或AtomicReference；
		c).将它的引用存储到由锁正确保护的域中。
20.安全的共享对象：
	1).线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改。
		a).Ad-hoc 线程限制：是指维护线程限制性的任务全部落在实现上的这种情况。鉴于ad-hoc线程限制固有的易损性，因此应该有节制地使用它。如果可能的话，用一种线程的强形式（栈限制或者Thread Local）取代它。 
			// ad-hoc的言外之意是“非正式的”。比如，在大学的餐厅中，你决定和某人谈谈业务，这就是一种“Ad-hoc”会谈。在这里 ad-hoc 是指未经过设计而得到的线程封闭行为。
		b).栈限制：栈限制是线程限制的一种特例，在栈限制中，只能通过本地变量才可以触及对象。
		c).ThreadLocal:ThreadLocal提供了get与set访问器，为每个使用它的线程维护一份单独的拷贝。所以get总是返回由当前执行线程通过set设置的最新值。线程本地（ThreadLocal）变量通常用于防止基于可变的单体或全局变量的设计中，
			出现不正确的共享。
	2).共享只读：一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发地访问，但是任何线程都不能修改它。共享只读对象包括可变对象与高效不可变对象。
	3).共享线程安全：一个线程安全的对象在内部进行同步，所以其他线程无须额外同步，就可以通过公共接口随意地访问它。
	4).被守护的：一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象。
	
四、组合对象
21.设计线程安全类的过程应该包括下面3个基本要素：
	1).确定对象状态是由哪些变量构成的;
	2).确定限制状态变量的不变约束;
	3).制定一个管理并发访问对象状态的策略。
21.1
	对象的状态首先要从它的域说起。如果对象的域都是基本类型(primitive)的，那么这些域就组成了对象的完整状态。一个对象有n个基本域(primitive fields)，它的状态就是域值组成的n元组(n-tuple);如果一个对象的域引用了其他对象，那么它的状态也同时包含了被引用对象的域。
22.同步策略：定义了对象如何协调对其他状态的访问，并且不会违反它的不变约束或后验条件。它规定了如何把不可变形、线程限制和锁结合起来，从而维护线程的安全性，还指明了哪些锁保护哪些变量。
	起草一个同步策略需要作出一系列的决策：将哪些变量声明为volatile类型，哪些变量被锁保护，哪个锁保护哪些变量，哪等等些变量是不可变的或者被限制在线程中的，哪些操作必须是原子的。出于日后维护的考虑，应该为它们编写文档。
	
23.线程可能会因为几种原因被阻塞或暂停：等待I/O操作结束，等待获得一个锁，等待从Thread.sleep中唤醒，或者是等待另一个线程的计算结果。当一个线程阻塞时，它通常被挂起，并被设置成线程阻塞的某个状态（BLOCKED，WAITING，或是TIMED_WAITING)

24：
	1.ConCurrentHashMap使用了一个更加细化的锁机制，叫分离锁，这个机制允许更深层次的共享访问。size和isEmpty，它们的语义在反映容器并发特性上被轻微地弱化了。size返回一个近似值而不是一个精确值
	2.CopyOnWriteArrayList:是同步List的一个并发替代品，通常它提供了更好的并发性，并避免了在迭代期间对容器加锁和复制。（相似地，CopyOnWriteArraySet是Set的并发替代品）。
	写入时复制(copy-on-write) 容器的线程安全性来源于这样一个事实，只要有效的不可变对象被正确发布，那么访问它将不再需要更多的同步。在每次需要修改时，它们会创建并重新发布一个新的容器拷贝，以此来实现可变性。 所以改变时复制基础数组需要一定的开销，当对容器迭代操作的频率远远高于对容器修改的频率时，使用“写入时复制”容器是个合理的选择
	
	3.BlockingQueue(阻塞队列)提供了可阻塞的put和take方法，如果Queue满了，put方法会被阻塞直到有空间可用;如果Queue是空的，那么take方法会被阻塞，直到有元素可用。Queue的长度可以有限，也可无限;
		类库中包含了一些BlockingQueue的实现，其中LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，与LinkedList和ArrayList相似，但是却拥有比同步List更好的并发性能。
		PriorityBlockingQueue是一个按优先顺序排序的队列，当你不希望按照FIFO的顺序处理元素时，这个PriorityBlockingQueue非常有用的。正如其他排序的容器一样，PriorityBlockQueue可以比较元素本身的自然顺序(如果它们实现了Comparable)，也可以进行一个Comparator进行排序。
		最后一个BlockingQueue的实现是SynchronousQueue，它根本不是一个真正的队列，因为它不会为队列元素维护任何存储空间。它维护一个排队的线程清单，这些线程等待把元素加入队列或者移除队列。因为SynchronousQueue没有存储的能力，所以除非另一个线程已经准备好参与移交工作，否则put和take会一直阻止。SynchronousQueue这类队列只有在消费者充足的时候比较合适，它们总能为下一个任务做好准备。
		
		java6新增两个容器类型：Deque(发音是Deck)和BlockingDeque，它们分别扩展了Queue和BlockingQueue。Deque是一个双端队列，允许高效地在头和尾分别进行插入和移除，实现它们的是ArrayDeque和LinkedBlockingQueue.
		正如阻塞队列适用于生产者-消费者模式一样，双端队列使它们自身与一种叫做窃取工作的模式相关联。如果一个消费者完成了自己双端队列中的全部工作，它可以偷取其他消费者的双端队列中的  末尾  任务。窃取工作做恰好适用于解决消费者与生产者筒体的问题-------当运行到一个任务的某单元时，可能会识别出更多的任务。比如Web Crawler处理一个页面时，通常会发现有更多页面可以搜索。当双端队列为空的时候，它会去其他队列的队尾寻找新的任务。
	
	一个阻塞的操作和一个普通的操作之间的差别仅仅在于，被阻塞的线程必须等待一个事件的发生才能继续进行，并且这个事件是超越它自己控制的，因而需要花费更长的时间-----等待I/O操作完成，锁可用，或是外部计算结束。
	
	BlockingQueue的put和take方法会抛出一个受检查的InterruptedException，能抛出InterruptedException的时候，是在说明这个方法是一个可阻塞的方法，如果他被中断，将可以提前结束阻塞状态。
	
	中断   是一种协作机制。一个线程不能够迫使其他线程停止正在做的事情，或者去做其他事情；当线程A中断B时，A仅仅是要求B在达成某个方便停止的关键点时，停止正在做的事情。
	当代码中调用了一个会抛出InterruptedException的方法时，你自己的方法也就成为了一个阻塞方法，要为响应中断作好准备。在类库代码中，有两种基本选择：
		传递InterruptedException：把InterruptedException传递给你的调用者。
		恢复中断：有时候不能抛出InterruptedException，必须捕获，在当前线程中通过调用interrupt从中断中恢复，这样调用栈中更高层的代码可以发现中断已经发生。
		
		不应该捕获了interruptedException而不做任何响应。这样会丢失线程中断的证据，从而剥夺了上层栈的代码处理中断的机会。只有一种情况允许覆盖中断：你扩展了Thread，并因此控制了所有处于调用栈上层的代码。
		
24.Synchronizer是一个对象，它根据本身的状态调节线程的控制流。阻塞队列可扮演一个Synchronizer的角色；其他类型的Synchronizer包括信号量(semaphore)、关卡(barrier)以及闭锁(latch)。在平台类库中存在一些Synchronizer类；
所有Synchronizer都享有类似的结构特性它们封装状态，而这些状态决定着线程执行到在某一点时是通过还是被迫等待；它们还提供操控状态的方法，以及高效地等待Synchronizer进入到期望状态的方法。
	闭锁(latch)：是一种Synchronizer，它可以延迟线程的进度直到线程达到终止(terminal)状态。一个闭锁工作起来就像一道大门：直到闭锁达到终点状态之前，门一直是关闭的，没有线程能够通过，在重点状态到来的时候，门开了，允许所有线程都通过。一旦闭锁到达了终点，它就不能再改变状态了，所以它会永远保持敞开状态。闭锁可以用来确保特定活动直到其他的活动完成后才发生，比如：
		1).确保一个计算不会执行，直到它需要的资源被初始化，一个二元闭锁(两个状态)可以用来表达“资源R已经被初始化”，并且所有需要用到R的活动首先都要在闭锁中等待。
		
		2).确保一个服务不会开始，直到它依赖的其他服务都已经开始。每一个服务会包含一个相关的二元闭锁；开启服务S会首先开始等待闭锁S中所依赖的其他服务，在启动结束后，会释放闭锁S，这样所有依赖S的服务也可以开始处理了。
		
		3).等待，直到活动的所有部分都为继续处理作好充分准备，比如在多玩家的游戏中的所有玩家是否都准备就绪。这样的闭锁会在所有玩家准备就绪时，达到终点状态。
		
		CountDownLatch是一个灵活的闭锁实现，用于上述各种情况；允许一个或多个线程等待一个事件集的发生。闭锁的状态包括一个计数器，初始化为一个正数，用来表现需要等待的事件数。countDown方法对计数器做减操作，表示一个事件已经发生了，而await方法等待计数器达到零，此时所有需要等待的事件都已发生。如果计数器入口时值为非零，await会一直阻塞直到计数器为零，或者等待线程中断以及超时。
		
		FutureTask 同样可以作为闭锁。FutureTask的计算是通过Callable实现的，它等价于一个可携带结果的Runnable，并且有3个状态：等待、运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。一旦FutureTask进入完成状态，它会永远停止在这个状态上。
		
		Future.get的行为依赖于任务的状态。如果它已经完成，get可以立刻得到返回结果，否则会被阻塞直到任务转入完成状态，然后回返回结果或抛出异常。FutureTask把计算的结果从运行计算的线程传送到需要这个结果的线程；FutureTask的规约保证了这种传递建立在结果的安全发布基础之上。
		
25.信号量
	1).计数信号量：用来控制能够同时访问某特定资源的活动的数量，或者同时执行某一给定操作的数量。计数信号量可以用来实现资源池或者给一个容器限定边界。
	
	2).一个Semaphore/[ˈsɛməˌfɔr, -ˌfor]/管理一个有效的许可(permit)集：许可的初始量通过构造函数传递给Semaphore。活动能够获得许可(只要还有剩余许可)，并在使用之后释放许可。如果已经没有可用的许可了，那么acquire会被阻塞，直到有可用的为止(或者直到被中断或者操作超时)。release方法向信号量返回一个许可。实现起来并没有真正的许可对象，并且Semaphore并没有真正向线程分配许可，所以一个线程得到的许可，可能是其他线程释放的。你可以把acquire看作是消费掉一个许可，而release看作创建一个许可；许可的数量并不会限制Semaphore。
	3).二元信号量：是计算信号量的退化形式，一个计数初始值为1的Semaphore。二元信号量可用作互斥(mutex)锁，它有不可重入锁的语意；谁拥有这个唯一的许可，就拥有了互斥锁。
	
	信号量可以用来实现资源池，比如数据库连接池。当池为空时，需要做的是阻塞它，然后在它不空时，再次解除阻塞。如果以池的大小初始化一个Semaphore，在你从池中获取资源之前，你应该调用acquire方法获取一个许可，调用release把许可放回资源池。acquire会一直阻塞，直到池不再为空
	
26.关卡：类似于闭锁，它们都能够阻塞一组线程，直到某些事情发生，关卡与闭锁不同之处在于，所有线程必须同时到达关卡点，才能继续处理。闭锁等待的是事件；关卡等待的是其他线程。就像一些家庭成员指定商场中的集合地点：“我们每个人6点在麦当劳见，到了以后不见不散，之后我们再决定接下里做什么”

	CyclicBarrier允许一个给定数量的成员多次集中在一个关卡点，这在并行迭代算法中非常有用，这个算法会把一个问题拆分成一些列相互独立的子问题。当线程到达关卡点时，调用await，await会被阻塞，直到所有线程都到达关卡点。如果所有线程都到达了关卡点，关卡就被成功地突破，这样所有线程都被释放，关卡会重置以备下一次使用。如果对await的调用超时，或者阻塞中的线程被中断，那么关卡就被认为是失败的，所有对await未完成的调用都通过BrokenBarrierException终止。如果成功地通过关卡，await为每一个线程返回一个唯一的到达索引号，可以用它来“选举”产生一个领导，在下一次迭代中承担一些特殊工作。CyclicBarrier也允许你向构造函数传递一个关卡行为(barrier action)：这是一个Runnable，当成功通过关卡的时候，会(在一个子任务线程中)执行，但是在阻塞线程被释放之前是不能执行的。
	
	关卡通常用来模拟这种情况：一个步骤的计算可以并行完成，但是要求必须完成所有与一个步骤相关的工作后才能进入下一步。
	
	Exchanger 是关卡的另一种形式，它是一种两步关卡，在关卡点会交换数据。当两方进行的活动不对称时，Exchanger是非常有用的，比如当一个线程向缓冲写入一个数据，这时另一个线程充当消费者使用这个数据；这些线程可以使用Exchanger进行会面，并用完整的缓冲与空缓冲进行交换。
	
第一部分的总结：
	1).可变状态
		所有并发问题都归结为如何协调访问并发状态。可变状态越少，保证线程安全就越容易。
	2).尽量将域声明为final类型，除非它们的需要是可变的。
	3).不可变对象天生是线程安全的。
		不可变对象极大地减轻了并发编程的压力。它们简单而安全，可以在没有锁或者防御性复制的情况下自由地共享。
	4).封装使管理复杂度变得更可行。
		你固然可以存储于全局变量的数据来写一个线程安全类，但是你为什么要这样做？在对象中封装数据，让它们能够更加容易地保持不变；在对象中封装同步，使它能够更容易地遵守同步策略。
	5).用锁来守护每一个可变变量。
	6).对同一不变约束中的所有变量都是用相同的锁。
	7).在运行复合操作期间持有锁。
	8).在非同步的多线程情况下，访问可变变量的程序是存在隐患的。
	9).不要依赖于可以需要同步的小聪明。
	10).在设计过程中就考虑线程安全，或者在文档中明确地说明它不是线程安全的。
	11).文档化你的同步策略。
	
第二部分：构建并发应用程序
1.任务执行：大多数并发应用程序是围绕执行任务进行管理的。所谓任务就是抽象、离散的工作单元。把一个应用程序的工作分离到任务中，可以简化程序的管理：这种分离还在不同事物间划分了自然的分界线，可以方便程序在出现错误时进行恢复；同时这种分离还可以为并行工作提供一个自然的结构，有利于提高程序的并发性。

2.无限制创建线程的缺点：
	1).线程生命周期的开销。线程的创建与关闭不是免费的。如果请求是频繁的且轻量的，那么为每一个请求创建一个新线程的做法就会消耗大量的计算资源。
	2).资源消耗量。活动线程会消耗系统资源，尤其是内存。如果可运行的线程数多于可用于的处理器数，线程就会空闲。大量空闲线程占用更多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时，还会产生其他的性能开销。
	3)稳定性。应该限制可创建线程的数目。限制的数目依平台而定，同时也受到JVM的  启动参数、Thread的构造函数中请求的栈大小等因素的影响，以及底层操作系统线程的额限制。如果打破限制，则会OutOfMemoryError。
	
3).执行策略：将任务的提交与任务的执行体进行解耦，它的价值在于让你可以简单地为一个类给定的任务制定执行策略，并且保证后续的修改不至于太困难。
	执行策略指明任务执行的几个因素：
		1).任务在什么(what)线程中执行
		2).任务以什么(what)顺序执行(FIFO,LIFO,优先级)
		3).可以有多少个(how many)任务并发执行
		4).可以有多少个(how many)任务进入等待执行队列
		5).如果系统过载，需要放弃一个任务，应该挑选哪一个(which)任务？另外，如何(how)通知应用程序知道这一切
		6).在一个任务的执行前与结束后，应该做什么(what)处理？
	执行策略是资源管理工具。最佳策略取决于可用的计算资源和你对服务质量源耗尽而失败，大量任务也不会在争夺稀缺资源时出现性能问题。
	
	无论何时当你看到这种形式的代码：
	new Thread(runnable).start() 并且你可能最终获得一个更加灵活的执行策略时，请认真考虑使用Executor代替Thread
	Executors.newFixedThreadPool(4);
	
4).线程池：线程池管理一个工作者线程的同构池(homogeneous pool)。线程池是与工作队列(work queue)紧密绑定的。所谓工作队列，其作用是持有所有等待执行的任务。工作者线程的生活从此轻松起来：它从工作队列中获取下一个任务，执行它，然后回来继续等待另一个线程。
	通过Executors中的某个静态工厂方法来创建一个线程：
		1).newFixedThreadPool 创建一个定长的线程池，每当提交一个任务就创建一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化(如果一个线程由于非预期的Exception而结束，线程池会补充一个新的线程）。
		2).newCachedThreadPool创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活地回收空闲的线程，当需求增加时，它可以灵活地添加新的线程，而并不会对池的长度作任何限制。
		3).newBingleThreadExecutor创建一个单线程化的executor，它只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它。executor会保证任务依照任务队列所规定的顺序（FIFO，LIFO，优先级）执行。
		4).newScheduledThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer.
		
		newFixedThreadPool和newCachedThreadPool两个工厂方法返回通用目的的ThreadPoolExecutor实例。直接使用ThreadPoolExecutor,也能创建更满足某些专有领域的executor
		
5).Executor的生命周期
	ExecutorService暗示了生命周期有3中状态：运行(running)、关闭(shutting down)和终止(terminated)。ExecutorService最初创建后的初始状态是运行状态。shutdown方法会启动一个平缓的关闭过程：停止接受新的任务，同时等待已经提交的任务完成-----包括尚未开始执行的任务。shutdownNow方法会启动一个强制的关闭过程：尝试取消所有运行中的任务和排在队列中尚未开始的任务。
	在关闭后提交到ExecutorService中的任务，会被拒绝执行处理器(rejected execution handler)处理。拒绝执行处理器(拒绝执行处理器是ExecutorService的一种实现，ThreadPoolExecutor提供的，ExecutorService接口中的方法并不提供拒绝执行处理器。)可能只是简单地放弃任务，也可能会引起execute抛出一个未检查的RejectedExecutionException。一旦所有的任务全部完成后，ExecutorService会转入终止状态。你可以调用awaitTermination等待ExecutorService到达终止状态，也可以轮询检查isTerminated判断ExecutorService是否已经终止。通常shutdown会紧随awaitTermination之后，这样可以产生同步地关闭ExecutorService的效果。
		