java并发编程实践
原子性：同一个时刻只有一个线程对它操作。
1.无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对变量的访问。java中首要的同步机制是synchronized关键字，它提供了独占锁。除此之外，术语“同步”还包括volatile变量，显示锁和原子	变量的使用
	在没有正确同步的情况下，如果多个线程访问了同一个变量，你的程序就存在隐患。有3种方法修复它：
		a).不要跨线程共享变量
		b).使状态变量为不可变的；
		c).在任何访问状态变量的时候使用同步
2.竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。
竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。
3.线程安全型：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。要求无论是多线程中的时序或交替操作，都要保证不破坏那些不变约束。
4.java.util.concurrent.atomic 包中包括了原子变量类，这些类用来实现数字和对象引用的原子状态转换。
5.每个java对象都可以隐式地扮演一个用于同步的锁的角色：这些内置的锁被称作内部锁或监视器锁。执行线程进入synchronized块之前会自动获得锁；而无论通过正常控制路径退出，还是从块中抛出异常，线	程都在放弃对synchronized块的控制时自动释放锁。获得内部锁的唯一途径事：进入这个内部锁保护的同步块或方法。
6.互斥锁：内部锁在Java中扮演了互斥所的角色。意味着至多只有一个线程可以拥有锁，当线程A尝试请求一个被线程B占有的锁时，线程A必须等待或者阻塞，直到B释放它。如果B永远不释放锁，A将永远等下去
7.对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的。
8.即使获得了与对象关联的锁也不能阻止其他线程访问这个对象，获得对象的锁后，唯一可以做的事情是阻止其他线程再获得相同的锁。
9.一种常见的锁规则是在对象内部封装所有的可变状态，通过对象的内部锁来同步任何访问可变状态的代码路径，保护他在并发访问中的安全。
10.对于每一个涉及多个变量的不变约束，需要同一个锁保护其所有的变量。
11.使用两种不同的同步机制会引起混淆，而且性能与安全也不能从中得到额外的好处。
12.通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地为了性能而牺牲简单性。
13.同步数据，避免访问过期值，使用  get/set 封装 。并在方法上加上 synchronized 关键字或者使用锁
14.锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步。
15.volatile：它确保对一个变量的更新以可预见的方式告知其他的线程。
16.正确使用volatile变量的方式：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件(比如初始化或关闭)的发生。他们通常当做标识完成、中断、状态的标记使用。volatile不足以使自增操作原子化。  当验证正确性必须推断可见性问题时，应该避免使用volatile变量。加锁可以保证可见性和原子性；volatile只能保证可见性。
只有满足以下所有标准，才能使用volatile变量
	a).写入变量时并不依赖变量的当前值；或者能够确保只有单一的线程修改变量的值。  所以i++ 不适合。
	b).变量不需要与其他的状态变量共同参与不变约束，而且访问变量时，没有其他的原因需要加锁。
	
17.发布：发布一个对象的意思是使它能够被当前范围之外的代码所使用。比如将一个引用存储到其他代码可以访问的地方，在一个非私有的方法中返回这个引用，也可以把它传递到其他类的方法中。
18.逸出：一个对象在尚未准备好时就将它发布，称为逸出
19.为了安全的发布对象，对象的引用以及对象的状态必须同时对其他线程可见。
	可通过下列条件安全的发布一个正确创建的对象：
		a).通过静态初始化器初始化对象的引用
		b).将它的引用存储到volatile域或AtomicReference；
		c).将它的引用存储到由锁正确保护的域中。
20.安全的共享对象：
	1).线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改。
		a).Ad-hoc 线程限制：是指维护线程限制性的任务全部落在实现上的这种情况。鉴于ad-hoc线程限制固有的易损性，因此应该有节制地使用它。如果可能的话，用一种线程的强形式（栈限制或者Thread Local）取代它。 
			// ad-hoc的言外之意是“非正式的”。比如，在大学的餐厅中，你决定和某人谈谈业务，这就是一种“Ad-hoc”会谈。在这里 ad-hoc 是指未经过设计而得到的线程封闭行为。
		b).栈限制：栈限制是线程限制的一种特例，在栈限制中，只能通过本地变量才可以触及对象。
		c).ThreadLocal:ThreadLocal提供了get与set访问器，为每个使用它的线程维护一份单独的拷贝。所以get总是返回由当前执行线程通过set设置的最新值。线程本地（ThreadLocal）变量通常用于防止基于可变的单体或全局变量的设计中，
			出现不正确的共享。
	2).共享只读：一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发地访问，但是任何线程都不能修改它。共享只读对象包括可变对象与高效不可变对象。
	3).共享线程安全：一个线程安全的对象在内部进行同步，所以其他线程无须额外同步，就可以通过公共接口随意地访问它。
	4).被守护的：一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象。
	
四、组合对象
21.设计线程安全类的过程应该包括下面3个基本要素：
	1).确定对象状态是由哪些变量构成的;
	2).确定限制状态变量的不变约束;
	3).制定一个管理并发访问对象状态的策略。
21.1
	对象的状态首先要从它的域说起。如果对象的域都是基本类型(primitive)的，那么这些域就组成了对象的完整状态。一个对象有n个基本域(primitive fields)，它的状态就是域值组成的n元组(n-tuple);如果一个对象的域引用了其他对象，那么它的状态也同时包含了被引用对象的域。
22.同步策略：定义了对象如何协调对其他状态的访问，并且不会违反它的不变约束或后验条件。它规定了如何把不可变形、线程限制和锁结合起来，从而维护线程的安全性，还指明了哪些锁保护哪些变量。
