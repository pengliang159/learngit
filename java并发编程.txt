java并发编程实践
原子性：同一个时刻只有一个线程对它操作。
1.无论何时，只要有多于一个的线程访问给定的状态变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对变量的访问。java中首要的同步机制是synchronized关键字，它提供了独占锁。除此之外，术语“同步”还包括volatile变量，显示锁和原子	变量的使用
	在没有正确同步的情况下，如果多个线程访问了同一个变量，你的程序就存在隐患。有3种方法修复它：
		a).不要跨线程共享变量
		b).使状态变量为不可变的；
		c).在任何访问状态变量的时候使用同步
2.竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。
竞态条件（race condition）是指设备或系统出现不恰当的执行时序，而得到不正确的结果。
3.线程安全型：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。要求无论是多线程中的时序或交替操作，都要保证不破坏那些不变约束。
4.java.util.concurrent.atomic 包中包括了原子变量类，这些类用来实现数字和对象引用的原子状态转换。
5.每个java对象都可以隐式地扮演一个用于同步的锁的角色：这些内置的锁被称作内部锁或监视器锁。执行线程进入synchronized块之前会自动获得锁；而无论通过正常控制路径退出，还是从块中抛出异常，线	程都在放弃对synchronized块的控制时自动释放锁。获得内部锁的唯一途径事：进入这个内部锁保护的同步块或方法。
6.互斥锁：内部锁在Java中扮演了互斥所的角色。意味着至多只有一个线程可以拥有锁，当线程A尝试请求一个被线程B占有的锁时，线程A必须等待或者阻塞，直到B释放它。如果B永远不释放锁，A将永远等下去
7.对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护的。
8.即使获得了与对象关联的锁也不能阻止其他线程访问这个对象，获得对象的锁后，唯一可以做的事情是阻止其他线程再获得相同的锁。
9.一种常见的锁规则是在对象内部封装所有的可变状态，通过对象的内部锁来同步任何访问可变状态的代码路径，保护他在并发访问中的安全。
10.对于每一个涉及多个变量的不变约束，需要同一个锁保护其所有的变量。
11.使用两种不同的同步机制会引起混淆，而且性能与安全也不能从中得到额外的好处。
12.通常简单性与性能之间是相互牵制的。实现一个同步策略时，不要过早地为了性能而牺牲简单性。
13.同步数据，避免访问过期值，使用  get/set 封装 。并在方法上加上 synchronized 关键字或者使用锁
14.锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步。
15.volatile：它确保对一个变量的更新以可预见的方式告知其他的线程。
16.正确使用volatile变量的方式：用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件(比如初始化或关闭)的发生。他们通常当做标识完成、中断、状态的标记使用。volatile不足以使自增操作原子化。  当验证正确性必须推断可见性问题时，应该避免使用volatile变量。加锁可以保证可见性和原子性；volatile只能保证可见性。
只有满足以下所有标准，才能使用volatile变量
	a).写入变量时并不依赖变量的当前值；或者能够确保只有单一的线程修改变量的值。  所以i++ 不适合。
	b).变量不需要与其他的状态变量共同参与不变约束，而且访问变量时，没有其他的原因需要加锁。
	
17.发布：发布一个对象的意思是使它能够被当前范围之外的代码所使用。比如将一个引用存储到其他代码可以访问的地方，在一个非私有的方法中返回这个引用，也可以把它传递到其他类的方法中。
18.逸出：一个对象在尚未准备好时就将它发布，称为逸出